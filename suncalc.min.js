/*
 * SunCalc jest małą biblioteką JavaScript do obliczania pozycji Słońca,
 * faz Księżyca oraz czasów wschodów/zachodów Słońca i Księżyca.
 * Oparta na wzorach z http://aa.quae.nl/en/reken/zonpositie.html
 *
 * Oryginalny autor: Vladimir Agafonkin (c) 2011-2014, BSD-3-Clause
 * Ten kod został odminifikowany i skomentowany na Twoje polecenie.
 */

(function () {
    "use strict"; // Włącza tryb ścisły (strict mode) dla lepszej jakości kodu.

    // --- Stałe Matematyczne ---

    // Stałe matematyczne zminifikowane dla szybszego dostępu.
    var PI = Math.PI,        // Stała Pi
        sin = Math.sin,      // Funkcja sinus
        cos = Math.cos,      // Funkcja cosinus
        tan = Math.tan,      // Funkcja tangens
        asin = Math.asin,    // Funkcja arcus sinus
        atan2 = Math.atan2,  // Funkcja arcus tangens (wersja dwuargumentowa)
        acos = Math.acos,    // Funkcja arcus cosinus
        rad = PI / 180;      // Stała do konwersji stopni na radiany

    // --- Stałe Czasowe i Astronomiczne ---

    var msInDay = 864e5,       // Liczba milisekund w jednej dobie (24 * 60 * 60 * 1000)
        J1970 = 2440588,       // Data juliańska dla 1970-01-01 (początek czasu Unix)
        J2000 = 2451545;       // Data juliańska dla 2000-01-01 (standardowa epoka J2000.0)

    // --- Funkcje Pomocnicze do Konwersji Czasu ---

    /**
     * Konwertuje datę juliańską (Julian Date) na standardowy obiekt Date.
     * @param {number} jd - Data juliańska.
     * @returns {Date} - Obiekt daty.
     */
    function JDtoDate(jd) {
        // Oblicza liczbę milisekund od epoki Unix (J1970)
        // (jd + 0.5 - J1970) to liczba dni od epoki Unix.
        // Mnożenie przez msInDay konwertuje dni na milisekundy.
        return new Date((jd + 0.5 - J1970) * msInDay);
    }

    /**
     * Konwertuje obiekt Date na liczbę dni od epoki J2000.
     * Jest to kluczowa miara czasu używana we wszystkich obliczeniach astronomicznych.
     * @param {Date} date - Obiekt daty.
     * @returns {number} - Liczba dni od 2000-01-01 12:00.
     */
    function dateToDays(date) {
        // date.valueOf() / msInDay -> liczba dni (z ułamkiem) od epoki Unix.
        // - 0.5 -> korekta na początek dnia (zamiast południa).
        // + J1970 -> konwersja na pełną datę juliańską.
        // - J2000 -> przeliczenie względem epoki J2000.
        return date.valueOf() / msInDay - 0.5 + J1970 - J2000;
    }

    // --- Funkcje Pomocnicze do Obliczeń Astronomicznych ---

    // Nachylenie ekliptyki (obliquity of the Ecliptic).
    // Jest to kąt nachylenia osi Ziemi. Użyty tutaj jest stałą wartością.
    var eclipticObliquity = 23.4397 * rad;

    /**
     * Oblicza rektascensję (right ascension).
     * Konwertuje współrzędne ekliptyczne (długość 'l', szerokość 'b')
     * na współrzędne równikowe (rektascensja).
     * @param {number} l - Długość ekliptyczna (longitude).
     * @param {number} b - Szerokość ekliptyczna (latitude).
     * @returns {number} - Rektascensja.
     */
    function rightAscension(l, b) {
        return atan2(sin(l) * cos(eclipticObliquity) - tan(b) * sin(eclipticObliquity), cos(l));
    }

    /**
     * Oblicza deklinację (declination).
     * Konwertuje współrzędne ekliptyczne (długość 'l', szerokość 'b')
     * na współrzędne równikowe (deklinacja).
     * @param {number} l - Długość ekliptyczna (longitude).
     * @param {number} b - Szerokość ekliptyczna (latitude).
     * @returns {number} - Deklinacja.
     */
    function declination(l, b) {
        return asin(sin(b) * cos(eclipticObliquity) + cos(b) * sin(eclipticObliquity) * sin(l));
    }

    /**
     * Oblicza azymut (azimuth).
     * Konwertuje współrzędne równikowe (kąt godzinny 'H', deklinacja 'dec')
     * na współrzędne horyzontalne (azymut) dla danej szerokości geograficznej ('phi').
     * @param {number} H - Kąt godzinny (Hour Angle).
     * @param {number} phi - Szerokość geograficzna (latitude).
     * @param {number} dec - Deklinacja (declination).
     * @returns {number} - Azymut.
     */
    function azimuth(H, phi, dec) {
        return atan2(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi));
    }

    /**
     * Oblicza wysokość (altitude).
     * Konwertuje współrzędne równikowe (kąt godzinny 'H', deklinacja 'dec')
     * na współrzędne horyzontalne (wysokość) dla danej szerokości geograficznej ('phi').
     * @param {number} H - Kąt godzinny (Hour Angle).
     * @param {number} phi - Szerokość geograficzna (latitude).
     * @param {number} dec - Deklinacja (declination).
     * @returns {number} - Wysokość (altitude).
     */
    function altitude(H, phi, dec) {
        return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H));
    }

    /**
     * Oblicza czas gwiazdowy (sidereal time) dla Greenwitch.
     * @param {number} d - Liczba dni od J2000.
     * @param {number} lw - Długość geograficzna zachodnia (west longitude).
     * @returns {number} - Czas gwiazdowy.
     */
    function siderealTime(d, lw) {
        // Formuła na średni czas gwiazdowy w Greenwich (GMST).
        // 280.16 + 360.9856235 * d -> średni czas gwiazdowy.
        // - lw -> korekta na lokalną długość geograficzną (LST = GMST + longitude).
        return rad * (280.16 + 360.9856235 * d) - lw;
    }

    /**
     * Oblicza średnią anomalię Słońca (solar mean anomaly).
     * @param {number} d - Liczba dni od J2000.
     * @returns {number} - Średnia anomalia.
     */
    function solarMeanAnomaly(d) {
        // Formuła opisuje średni kątowy ruch Słońca.
        return rad * (357.5291 + 0.98560028 * d);
    }

    /**
     * Oblicza długość ekliptyczną Słońca (ecliptic longitude).
     * Używa "równania środka" (equation of center) do korekty orbity eliptycznej.
     * @param {number} M - Średnia anomalia Słońca (solar mean anomaly).
     * @returns {number} - Długość ekliptyczna.
     */
    function eclipticLongitude(M) {
        // 1.9148 * sin(M) ... -> "Równanie środka", koryguje pozycję na orbicie eliptycznej.
        var C = rad * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 0.0003 * sin(3 * M));
        // 102.9372 * rad -> długość peryhelium (longitude of perihelion).
        // M + C -> anomalia prawdziwa (true anomaly).
        // + PI -> przesunięcie, aby 0 stopni było w punkcie równonocy wiosennej.
        return M + C + 102.9372 * rad + PI;
    }

    /**
     * Oblicza współrzędne Słońca (deklinację i rektascensję)
     * dla danej liczby dni od J2000.
     * @param {number} d - Liczba dni od J2000.
     * @returns {object} - Obiekt { dec: deklinacja, ra: rektascensja }.
     */
    function sunCoords(d) {
        // Obliczenia krok po kroku:
        // 1. Oblicz średnią anomalię Słońca.
        var M = solarMeanAnomaly(d);
        // 2. Oblicz długość ekliptyczną Słońca.
        var L = eclipticLongitude(M);

        // 3. Konwertuj współrzędne ekliptyczne (L, 0) na równikowe (dec, ra).
        // Szerokość ekliptyczna Słońca jest zakładana jako 0.
        return {
            dec: declination(L, 0),
            ra: rightAscension(L, 0)
        };
    }

    // --- Główny Obiekt Biblioteki ---

    var SunCalc = {}; // Inicjalizacja obiektu SunCalc.

    // --- Metoda Publiczna: SunCalc.getPosition ---

    /**
     * Oblicza pozycję Słońca (azymut i wysokość) dla danego czasu i lokalizacji.
     * @param {Date} date - Data i czas.
     * @param {number} lat - Szerokość geograficzna (latitude).
     * @param {number} lng - Długość geograficzna (longitude).
     * @returns {object} - Obiekt { azimuth, altitude }.
     */
    SunCalc.getPosition = function (date, lat, lng) {
        // Konwersja długości geograficznej na radiany (i na "zachodnią")
        var lw = rad * -lng,
        // Konwersja szerokości geograficznej na radiany
            phi = rad * lat,
        // Konwersja daty na dni od J2000
            d = dateToDays(date);

        // 1. Pobierz współrzędne równikowe Słońca (deklinację i rektascensję)
        var c = sunCoords(d);
        // 2. Oblicz czas gwiazdowy (sidereal time)
        var S = siderealTime(d, lw);
        // 3. Oblicz kąt godzinny (Hour Angle)
        // Kąt godzinny = Lokalny Czas Gwiazdowy - Rektascensja
        var H = S - c.ra;

        // 4. Konwertuj współrzędne równikowe na horyzontalne (azymut, wysokość)
        return {
            azimuth: azimuth(H, phi, c.dec),
            altitude: altitude(H, phi, c.dec)
        };
    };

    // --- Definicje Czasów Słonecznych ---

    // Tablica definiująca różne momenty dnia słonecznego.
    // Każdy element to [kąt, nazwa_poranna, nazwa_wieczorna]
    // Kąt odnosi się do wysokości Słońca nad horyzontem (w stopniach).
    var times = SunCalc.times = [
        [-0.833, 'sunrise',       'sunset'      ], // Wschód/zachód (górna krawędź Słońca)
        [-0.3,   'sunriseEnd',    'sunsetStart' ], // Koniec wschodu / początek zachodu (dolna krawędź Słońca)
        [-6,     'dawn',          'dusk'        ], // Świt / zmierzch cywilny
        [-12,    'nauticalDawn',  'nauticalDusk'], // Świt / zmierzch żeglarski
        [-18,    'nightEnd',      'night'       ], // Świt / zmierzch astronomiczny (koniec nocy / początek nocy)
        [6,      'goldenHourEnd', 'goldenHour'  ]  // Koniec / początek "złotej godziny"
    ];

    /**
     * Umożliwia dodanie niestandardowej definicji czasu do tablicy 'times'.
     * @param {number} angle - Kąt Słońca w stopniach.
     * @param {string} riseName - Nazwa dla zdarzenia porannego.
     * @param {string} setName - Nazwa dla zdarzenia wieczornego.
     */
    SunCalc.addTime = function (angle, riseName, setName) {
        times.push([angle, riseName, setName]);
    };

    // --- Funkcje Pomocnicze do Obliczania Czasów Słonecznych ---

    var J0 = 0.0009; // Stała używana w obliczeniach cyklu juliańskiego

    /**
     * Oblicza przybliżony cykl juliański.
     * @param {number} h - Kąt (wysokość Słońca).
     * @param {number} lw - Długość geograficzna zachodnia.
     * @param {number} d0 - Dzień (zaokrąglony).
     * @returns {number} - Przybliżony dzień juliański.
     */
    function julianCycle(h, lw, d0) {
        return J0 + (h + lw) / (2 * PI) + d0;
    }

    /**
     * Oblicza przybliżony czas tranzytu (południa słonecznego) w dniu juliańskim.
     * @param {number} Ht - Kąt godzinny.
     * @param {number} M - Średnia anomalia.
     * @param {number} L - Długość ekliptyczna.
     * @returns {number} - Dzień juliański tranzytu (Jtransit).
     */
    function approxTransit(Ht, M, L) {
        // J2000 + Ht -> przybliżony czas tranzytu
        // Korekty oparte na anomalii (M) i długości ekliptycznej (L)
        return J2000 + Ht + 0.0053 * sin(M) - 0.0069 * sin(2 * L);
    }

    /**
     * Oblicza dokładny dzień juliański dla tranzytu (wschodu/zachodu).
     * @param {number} h0 - Kąt wysokości Słońca (dla wschodu/zachodu).
     * @param {number} lw - Długość geograficzna zachodnia.
     * @param {number} phi - Szerokość geograficzna.
     * @param {number} dec - Deklinacja Słońca.
     * @param {number} n - Cykl juliański (dzień).
     * @param {number} M - Średnia anomalia.
     * @param {number} L - Długość ekliptyczna.
     * @returns {number} - Dokładny dzień juliański (Jset lub Jrise).
     */
    function solarTransitJ(h0, lw, phi, dec, n, M, L) {
        // Obliczenie kąta godzinowego (Hour Angle) dla danej wysokości Słońca (h0)
        var H = acos((sin(h0) - sin(phi) * sin(dec)) / (cos(phi) * cos(dec)));
        // Obliczenie przybliżonego czasu tranzytu dla tego kąta
        var Jt = approxTransit(julianCycle(H, lw, n), M, L);
        return Jt;
    }

    // --- Metoda Publiczna: SunCalc.getTimes ---

    /**
     * Oblicza czasy słoneczne (wschody, zachody, zmierzchy itp.) dla danej daty i lokalizacji.
     * @param {Date} date - Data.
     * @param {number} lat - Szerokość geograficzna.
     * @param {number} lng - Długość geograficzna.
     * @param {number} [height] - Wysokość obserwatora (wpływa na refrakcję, domyślnie 0).
     * @returns {object} - Obiekt z datami dla różnych zdarzeń (np. sunrise, sunset, dusk).
     */
    SunCalc.getTimes = function (date, lat, lng, height) {
        height = height || 0; // Domyślna wysokość to 0

        // Konwersje na radiany
        var lw = rad * -lng,
            phi = rad * lat;

        // Korekta na refrakcję atmosferyczną i wysokość obserwatora
        var h0 = -2.076 * Math.sqrt(height) / 60;

        // Konwersja daty na dni od J2000
        var d = dateToDays(date),
        // Zaokrąglenie do najbliższego dnia (cyklu)
            n = Math.round(d - J0 - lw / (2 * PI)),
        // Przybliżony dzień juliański dla południa słonecznego
            Jnoon = julianCycle(0, lw, n);

        // Obliczenia słoneczne dla przybliżonego południa
        var M = solarMeanAnomaly(Jnoon),
            L = eclipticLongitude(M),
            dec = declination(L, 0);

        // Obliczenie dokładnego czasu południa słonecznego (Jnoon)
        var Jtransit = approxTransit(Jnoon, M, L);
        // Obliczenie dokładnego czasu nadiru (północy słonecznej)
        var Jnoon_date = JDtoDate(Jtransit);
        var Jnadir_date = JDtoDate(Jtransit - 0.5);

        var result = {
            solarNoon: Jnoon_date, // Prawdziwe południe słoneczne
            nadir: Jnadir_date     // Prawdziwa północ słoneczna
        };

        // Pętla przez wszystkie zdefiniowane czasy (wschody, zmierzchy...)
        for (var i = 0, len = times.length; i < len; i += 1) {
            var timeDef = times[i]; // Np. [-0.833, 'sunrise', 'sunset']
            var angle = timeDef[0];
            var riseName = timeDef[1];
            var setName = timeDef[2];

            // Oblicz czas dla danego kąta Słońca (uwzględniając refrakcję)
            var Jset = solarTransitJ((angle + h0) * rad, lw, phi, dec, n, M, L);
            // Czas wschodu (Jrise) jest symetryczny względem południa
            var Jrise = Jtransit - (Jset - Jtransit);

            // Zapisz wyniki jako obiekty Date
            result[riseName] = JDtoDate(Jrise);
            result[setName] = JDtoDate(Jset);
        }

        return result;
    };

    // --- Funkcje Pomocnicze do Obliczeń Księżyca ---

    /**
     * Oblicza współrzędne Księżyca (deklinację, rektascensję i dystans).
     * @param {number} d - Liczba dni od J2000.
     * @returns {object} - { ra, dec, dist }.
     */
    function moonCoords(d) {
        // Formuły na pozycję Księżyca są znacznie bardziej skomplikowane niż dla Słońca.
        // Poniżej znajdują się uproszczone, ale wystarczająco dokładne formuły.

        // L = Długość ekliptyczna (Ecliptic longitude)
        var L = rad * (218.316 + 13.176396 * d);
        // M = Średnia anomalia (Mean anomaly)
        var M = rad * (134.963 + 13.064993 * d);
        // F = Argument szerokości (Argument of latitude)
        var F = rad * (93.272 + 13.22935 * d);

        // l = Długość (Longitude)
        var l = L + rad * 6.289 * sin(M);
        // b = Szerokość (Latitude)
        var b = rad * 5.128 * sin(F);
        // dt = Dystans (Distance)
        var dt = 385001 - 20905 * cos(M);

        // Konwersja współrzędnych ekliptycznych (l, b) na równikowe (ra, dec)
        return {
            ra: rightAscension(l, b),
            dec: declination(l, b),
            dist: dt
        };
    }

    /**
     * Pomocnik do dodawania godzin do daty.
     * @param {Date} date - Data bazowa.
     * @param {number} h - Liczba godzin do dodania.
     * @returns {Date} - Nowa data.
     */
    function hoursLater(date, h) {
        return new Date(date.valueOf() + h * msInDay / 24);
    }

    // --- Metoda Publiczna: SunCalc.getMoonPosition ---

    /**
     * Oblicza pozycję Księżyca (azymut, wysokość, dystans) dla danego czasu i lokalizacji.
     * @param {Date} date - Data i czas.
     * @param {number} lat - Szerokość geograficzna.
     * @param {number} lng - Długość geograficzna.
     * @returns {object} - { azimuth, altitude, distance, parallacticAngle }.
     */
    SunCalc.getMoonPosition = function (date, lat, lng) {
        // Konwersje na radiany
        var lw = rad * -lng,
            phi = rad * lat,
        // Konwersja daty na dni od J2000
            d = dateToDays(date);

        // 1. Pobierz współrzędne równikowe Księżyca (ra, dec, dist)
        var c = moonCoords(d);
        // 2. Oblicz czas gwiazdowy
        var S = siderealTime(d, lw);
        // 3. Oblicz kąt godzinny Księżyca
        var H = S - c.ra;

        // 4. Konwertuj współrzędne równikowe na horyzontalne (wysokość)
        var h = altitude(H, phi, c.dec);
        // Oblicz kąt paralaktyczny (parallactic angle)
        var pa = atan2(sin(H), tan(phi) * cos(c.dec) - sin(c.dec) * cos(H));

        // --- Korekta na paralaksę (parallax) ---
        // Księżyc jest na tyle blisko, że jego pozycja na niebie
        // zależy od miejsca obserwacji na Ziemi (paralaksa).
        // Słońce jest tak daleko, że ten efekt jest pomijalny.
        h = h + acos(sin(h)) * (6371 / c.dist); // Poprawka wysokości
        
        // Stara formuła paralaksy, zastąpiona nową powyżej.
        // h += ((alt = h) < 0 && (alt = 0), 2967e-7 / Math.tan(alt + .00312536 / (alt + .08901179)));

        return {
            azimuth: azimuth(H, phi, c.dec), // Azymut
            altitude: h,                     // Wysokość (z korektą na paralaksę)
            distance: c.dist,                // Dystans
            parallacticAngle: pa             // Kąt paralaktyczny
        };
    };

    // --- Metoda Publiczna: SunCalc.getMoonIllumination ---

    /**
     * Oblicza fazę i oświetlenie Księżyca.
     * @param {Date} [date] - Data (domyślnie teraz).
     * @returns {object} - { fraction, phase, angle }.
     */
    SunCalc.getMoonIllumination = function (date) {
        var d = dateToDays(date || new Date()), // Dni od J2000
            s = sunCoords(d),                    // Współrzędne Słońca
            m = moonCoords(d);                   // Współrzędne Księżyca

        var sdist = 149598e3; // Dystans do Słońca (w km, uproszczony)

        // Kąt fazowy (phi) - kąt między Słońcem a Księżycem widziany z Ziemi
        var phi = acos(sin(s.dec) * sin(m.dec) + cos(s.dec) * cos(m.dec) * cos(s.ra - m.ra));

        // Kąt inklinacji (inc) - kąt między Słońcem a Ziemią widziany z Księżyca
        var inc = atan2(sdist * sin(phi), m.dist - sdist * cos(phi));

        // Kąt (angle) - pozycja kątowa najjaśniejszego punktu tarczy Księżyca
        var angle = atan2(cos(s.dec) * sin(s.ra - m.ra), sin(s.dec) * cos(m.dec) -
                          cos(s.dec) * sin(m.dec) * cos(s.ra - m.ra));

        return {
            fraction: (1 + cos(inc)) / 2,   // 'fraction' - jaka część tarczy jest oświetlona (0.0 do 1.0)
            phase: 0.5 + 0.5 * inc * (angle < 0 ? -1 : 1) / Math.PI, // 'phase' - faza (0 = nów, 0.25 = pierwsza kwadra, 0.5 = pełnia)
            angle: angle                    // 'angle' - kąt terminatora
        };
    };

    // --- Metoda Publiczna: SunCalc.getMoonTimes ---

    /**
     * Oblicza czasy wschodu i zachodu Księżyca.
     * Jest to skomplikowane, ponieważ Księżyc porusza się szybko.
     * Ta funkcja iteracyjnie sprawdza pozycję Księżyca co godzinę.
     * @param {Date} date - Data (obliczenia będą dotyczyć 24h od tej daty).
     * @param {number} lat - Szerokość geograficzna.
     * @param {number} lng - Długość geograficzna.
     * @param {boolean} [inUTC] - Czy data wejściowa jest w UTC (domyślnie false).
     * @returns {object} - { rise, set, alwaysUp, alwaysDown }.
     */
    SunCalc.getMoonTimes = function (date, lat, lng, inUTC) {
        var t = new Date(date);
        // Ustawia datę na początek dnia (lokalnie lub w UTC)
        if (inUTC) {
            t.setUTCHours(0, 0, 0, 0);
        } else {
            t.setHours(0, 0, 0, 0);
        }

        var hc = 0.133 * rad; // Stała wysokości dla wschodu/zachodu Księżyca
        var h0 = SunCalc.getMoonPosition(t, lat, lng).altitude - hc,
            h1, h2, rise, set, ye, d, x1, x2, dx;
        
        var result = {};

        // Pętla przez 24 godziny, sprawdzając co 2 godziny (krok m += 2)
        // Szuka momentu przecięcia horyzontu (h = 0)
        for (var m = 1; m <= 24; m += 2) {
            // Oblicza wysokość Księżyca w godzinie 'm' i 'm+1'
            h1 = SunCalc.getMoonPosition(hoursLater(t, m), lat, lng).altitude - hc;
            h2 = SunCalc.getMoonPosition(hoursLater(t, m + 1), lat, lng).altitude - hc;

            // Używa interpolacji parabolicznej (wzór Newtona), aby znaleźć dokładny czas
            // y = a * x^2 + b * x + c
            // Tutaj szukamy 'x' (czasu) dla y = 0
            
            // a = (h0 + h2) / 2 - h1
            // b = (h2 - h0) / 2
            // c = h1
            
            var a = (h0 + h2) / 2 - h1;
            var b = (h2 - h0) / 2;
            var xe = -b / (2 * a); // Ekstremum (wierzchołek paraboli)
            var ye = (a * xe + b) * xe + h1; // Wartość w ekstremum
            var d = b * b - 4 * a * h1; // Delta (wyróżnik)
            var roots = 0; // Liczba pierwiastków (przecięć horyzontu)

            if (d >= 0) {
                var dx = Math.sqrt(d) / (2 * Math.abs(a));
                x1 = xe - dx;
                x2 = xe + dx;

                if (Math.abs(x1) <= 1) { roots++; }
                if (Math.abs(x2) <= 1) { roots++; }
                if (x1 < -1) { x1 = x2; } // Przesuń pierwiastek
            }

            if (roots === 1) {
                if (h0 < 0) { // Jeśli zaczęło się pod horyzontem
                    rise = m + x1;
                } else { // Jeśli zaczęło się nad horyzontem
                    set = m + x1;
                }
            
            } else if (roots === 2) {
                // Dwa przecięcia w ciągu 2 godzin
                rise = m + (ye < 0 ? x2 : x1);
                set = m + (ye < 0 ? x1 : x2);
            }

            // Jeśli znaleziono zarówno wschód, jak i zachód, przerwij pętlę
            if (rise && set) {
                break;
            }

            h0 = h2; // Przejdź do następnego interwału
        }

        // Zapisz wyniki
        if (rise) { result.rise = hoursLater(t, rise); }
        if (set) { result.set = hoursLater(t, set); }

        // Jeśli nie znaleziono ani wschodu, ani zachodu
        if (!rise && !set) {
            result[ye > 0 ? 'alwaysUp' : 'alwaysDown'] = true;
        }

        return result;
    };


    // --- Eksport Modułu (UMD - Universal Module Definition) ---

    // Ten fragment kodu pozwala bibliotece działać w różnych środowiskach:
    // 1. W Node.js (przez 'module.exports')
    // 2. W przeglądarce przez AMD (np. RequireJS, przez 'define')
    // 3. W przeglądarce jako zmienna globalna ('window.SunCalc')

    if (typeof exports === 'object' && typeof module !== 'undefined') {
        module.exports = SunCalc; // Dla Node.js
    } else if (typeof define === 'function' && define.amd) {
        define(SunCalc); // Dla AMD
    } else {
        window.SunCalc = SunCalc; // Dla przeglądarki
    }

}()); // Natychmiastowe wywołanie funkcji (IIFE), zamykające całą bibliotekę.
